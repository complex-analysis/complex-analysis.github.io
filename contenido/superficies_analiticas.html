<!doctype html>
<html>

<head>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/png" href="../images/infinity32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="../images/infinity16.png" sizes="16x16">
  <title>Análisis Complejo</title>

	<!-- dublin core -->
	<meta name="dc.title" CONTENT="Análisis Complejo">
	<meta name="dc.creator" CONTENT="Juan Carlos Ponce Campuzano">
	<meta name="dc.date" CONTENT="26-01-2021">
    <meta name="dc.isbn" CONTENT="ISBN-13: ">
	<meta name="dc.type" CONTENT="Recurso Interactivo">
	<meta name="dc.format" CONTENT="HTML">
	<meta name="dc.language" CONTENT="es-MEX">
	<meta name="dc.rights" CONTENT="https://creativecommons.org/licenses/by-nc-sa/4.0/">

	<!-- social media cards -->
	<meta property="og:title" content="Análisis Complejo">
	<meta property="og:description" content="Una introducción visual e interactiva en línea al estudio del análisis complejo.">
	<meta property="og:type" content="website">
	<!--<meta property="og:image" content="">
	<meta property="og:url" content="">-->
	<meta name="twitter:card" content="Una introducción visual e interactiva en línea al estudio del análisis complejo.">
	<meta property="og:site_name" content="Análisis Complejo">


  <!-- FONTS AND CSS -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,600,800" rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/css?family=Lora:400,400italic,700,700italic" rel='stylesheet'
    type='text/css'>
  <link href="../css/stylesheet.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="../css/w3.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css">
  <!-- CODE PRETTIFY -->
  <!-- via: https://github.com/google/code-prettify -->
  <script src="../js/run_prettify.js"></script>



  <!-- JQUERY FANCY ADDITIONS -->
  <!-- add code class, hover text, etc -->
  <script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
  <script>
    $(document).ready(function () {

      // prettyprint the code, pls
      $('pre').addClass('prettyprint lang-java');

      // add word-breaks to anything with a / or - in it
      $('h1').each(function () {
        var t = $(this).text();
        t = t.replace('/', '/<wbr>');
        t = t.replace('-', '-<wbr>');
        $(this).html(t);
      });

      // set formatting
      resizeCommands();
    });

    // when the window gets resized, do some stuff to keep everything
    // looking pretty
    $(window).resize(function () {
      resizeCommands();
    });

    // things to do when the page is loaded or window resized
    function resizeCommands() {
      // large-screen stuff...
      if ($(window).width() > 600) {

        // long headline on intro page
        // $('#introHeadline').html('TABLE OF CONTENTS');

        // menu hover stuff on larger screens
        // (does weird formatting on larger screens)
        // hover over title to show "Table of Contents"
        $('#title a').hover(
          function () {
            $('#title a').text('Tabla de Contenidos');
          },
          function () {
            $('#title a').text('Análisis Complejo'); // set back when moving out
          }
        );

        // set prev/next titles
        $('#prev a').hover(
          function () {
            $('#title a').text('Prev: La Transformación 1/z');
          },
          function () {
            $('#title a').text('Análisis Complejo');
          }
        );
        $('#next a').hover(
          function () {
            $('#title a').text('Next: Dominio Coloreado');
          },
          function () {
            $('#title a').text('Análisis Complejo');
          }
        );
      }

      // small-screen stuff
      else {
        // short headline on intro page
        // $('#introHeadline').html('INTRO');
      }
    }
  </script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-155852901-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'UA-155852901-1');
  </script>

  <script src="../applets/mathcell/math.js"></script>
  <script src="../applets/mathcell/mathcell.js"></script>


  <!-- Cindy.js
    <link rel="stylesheet" href="../dclandscape/app.css" />
    <link rel="stylesheet" href="../dclandscape/CindyJS.css" /> -->
  <script type="text/javascript" src="../applets/cindyjs/assets/Cindy.js"></script>
  <script type="text/javascript" src="../applets/cindyjs/assets/CindyGL.js"></script>
  <script type="text/javascript" src="../applets/cindyjs/assets/symbolic.js"></script>
  <!-- Cindy.js -->

</head>

<body>
  <div id="wrapper">

    <header>
      <p><span id="prev"><a href="mapeo_1sobrez.html">&larr;</a></span><span id="title"><a
            href="tabla_de_contenidos.html">Análisis Complejo</a></span><span id="next"><a
            href="dominio_coloreado.html">&rarr;</a></span>
        <div class="clear"></div>
      </p>
    </header>


    <h1>Superficies Analíticas</h1>

    <hr>

    <h2>Una breve historia</h2>

    <p>
      Un concepto tradicional para visualizar funciones complejas es el de <em>superficie analítica</em>.
      Probablemente introducido por <a href="https://fr.wikipedia.org/wiki/Edmond_Maillet">Edmond Maillet</a>
      en 1903, el cual representa la gráfica del valor absoluto de una función.
    </p>

    <p>
      En la primera mitad del siglo XX, llas superficies analíticas se hicieron bastante populares. 
      La Figura 1 reproduce una ilustración histórica del libro 
      <em>Funktionentafeln mit Formeln und Kurven</em>
      escrito por Jahnke y Emde y publicado en 1909. 
      En esta imagen se muestra la superficie analítica de la función compleja
      <a href="http://mathworld.wolfram.com/GammaFunction.html">Gamma</a>
      y alcanzó un estatus casi icónico. ¡Hoy en día es difícil creer que esta imagen 
      detallada dibujada a mano pueda crearse sin la ayuda de las computadoras!
      <p>

        <figure class="w3-center">
          <img class="w3-image w3-mobile" src="../applets/cindyjs/dclandscape/Jahnke_gamma_function.png"
            alt="Analytic landscape" title="Analytic landscape" style="width:90%;">
          <figcaption>
            <b>Figura 1:</b> La superficie analítica de $\Gamma(z)$.
          </figcaption>
        </figure>

        <!--<p><img class="center" src="../images/Jahnke_gamma_function.png" alt="Analytic landscape" title="Analytic landscape"></p>-->

        <p>
          En la era de las ilustraciones en blanco y negro, esta deficiencia a menudo se 
          compensaba dotando a la superficie analítica de líneas curvas de argumento constante 
          como en la figura anterior, donde el argumento se indica explícitamente por 
          su valor numérico. La tecnología informática moderna nos permite lograr el 
          mismo efecto mucho mejor utilizando colores, lo que produce una 
          <em>superficie analítica coloreada</em> como la que se muestra en la Figura 2.
        </p>

        <figure class="w3-center">
          <img class="w3-image w3-mobile w3-hide-medium w3-hide-large" src="../applets/cindyjs/dclandscape/coloredlandscape.jpg"
            alt="Colored analytic landscape" title="Colored analytic landscape" style="width:90%;">
            <div class="mathcell w3-hide-small" style="width: 6in; height: 6in">
              <script>
                var parent = document.currentScript.parentNode;
    
                var id = generateId();
                parent.id = id;
    
                MathCell(id, []);
    
                parent.update = function (id) {
    
                  var p = parametric(
                    (x, y) => [x, y, gamma(complex(x, y))], [-4.999, 4.999, 201], [-4.999, 4.999, 201], {
                      complexFunction: 'abs',
                      colormap: 'complexArgument'
                    }
                  );
    
                  var config = {
                    type: 'threejs',
                    zMax: 8,
                    viewpoint: [-0.2,-1,0.5]
                  };
    
                  evaluate(id, [p], config);
    
                }
    
                parent.update(id);
              </script>
            </div>
            <figcaption>
            <b>Figura 2:</b> Superficie analítica coloreada de $\Gamma(z)$.
          </figcaption>
        </figure>


        <hr>

        <div id="complexLandscapes">

          <h2>Exploración Dinámica</h2>

          <p>Las funciones complejas $ f:\mathbb{C}\to\mathbb{C} $ 
            se pueden visualizar al graficar la función $g: \mathbb{R^2}
            \to \mathbb{R}$ with $$g(x,y) = |f\left(x + i y\right)|.$$
            El colo de cada punto $\left(x, y, g(x,y)\right)$ indica
             <a href="terminology_notation.html#phase-argument" target="_blank">la fase (o argument)</a> 
             del número complejo $f(x + i y)$.</p>

          <p>En el siguiente applet puedes explorar superficies analítcas 
            coloreadas. Usa el deslizador con punto azul del lado derecho para 
            acercar o alejar. 
            El deslizador con el punto blanco define un escalar 
            <strong>a</strong> $ \in [ -0.14, 1.14]$.</p>


          <script id="csmousedown" type="text/x-cindyscript">
            playanimation();
      framesdelay=0;
      sx = mouse().x;
      sy = mouse().y;
      dragging = sx < .5;
    </script>
          <script id="csmouseup" type="text/x-cindyscript">
            framesdelay=0;
      dragging = false;
    </script>


          <script id="csinit" type="text/x-cindyscript">
            speciala = .5;
      smootha(x) := if(x<speciala,
        (-1/(speciala+.01))*(x-speciala)^2+speciala,
        (1/(1.01-speciala))*(x-speciala)^2+speciala
      );
      
      seta(na) := (
        a = na;
        speciala = na;
        PA.y = (na-.5)*.7;
      );
      
      setzoom(zoom) := (
        PC.y = (zoom);
      );
      
      //initialize some variables
      mat = [[0,0,1],[1,0,0],[0,1,0]] * (
          (1, 0, 0),
          (0, cos(.3), -sin(.3)),
          (0, sin(.3), cos(.3))
      );

      sx = mouse().x;
      sy = mouse().y;
      dragging = false;
      N = 5;
      zoom = 2.2;
      a = 0.3;
      
      //we stand at position mat*(0, 0, -2.2) and watch to (0,0,0).
      //ray(t) is the point in R^3 that lies at position t the ray behind the pixel at location pixel(vec2)
      //t=0 is corresponds to points within the interesting area near (0,0,0)
      //ray(t) := mat * ((t+2.2) * (pixel.x, pixel.y, 1) + (0, 0, -2.2));
      
      ray(t) := t*mrd+mv;
      
      //sphere with radius 1 for clipping
      S(r) := (r * r - 1);
      
      //renders the function h(z)=p(z)/q(z);
      p(z):= z-1;
      q(z):= z^2+z+a;
      dp(z) = 1;
      dq(z) = 2*z+1;
      
      //F takes vec3 instead of 3 variables and is zoomed
      F(p) := (p.z=p.z+.7;p=p/zoom;
        z = p.z;
        xi = complex([p.x,p.y]);
        pxi = p(xi);
        qxi = q(xi);
        //z = |pxi/qxi| <=> z>=0 and z^2*|qxi|^2 - |pxi|^2=0
        z*z*(gauss(qxi)*gauss(qxi))-gauss(pxi)*gauss(pxi)  
      );
      
      dF(p) := (p.z=p.z+.7;p=p/zoom;
        z = p.z;
        xi = complex([p.x,p.y]);
        pxi = p(xi);
        qxi = q(xi);
        dpxi = dp(xi); //use symbolic differentiated function
        dqxi = dq(xi);
        ( 
          z*z*(2*(re(qxi)*re(dqxi)+im(qxi)*im(dqxi)))-2*(re(pxi)*re(dpxi)+im(pxi)*im(dpxi)), //d/dx(z*z*(gauss(qxi)*gauss(qxi))-gauss(pxi)*gauss(pxi))
          (z*z*(2*(-re(qxi)*im(dqxi)+im(qxi)*re(dqxi)))-2*(-re(pxi)*im(dpxi)+im(pxi)*re(dpxi))), //d/dx(z*z*(gauss(qxi)*gauss(qxi))-gauss(pxi)*gauss(pxi)), check https://en.wikiversity.org/wiki/Cauchy-Riemann_Equations
          2*z*(gauss(qxi)*gauss(qxi))
        )
      );
      
      color(z) := ( //what color should be given to a complex number z?
        regional(n, grey1, grey2);
        n = 12;
        z = log(z)/2/pi;

        zfract = n*z - floor(n*z); //value of n*z in C mod Z[i]

        grey1 = im(zfract);
        grey2 = re(zfract);
        
        hue(im(z))*(.7+.3*re(sqrt(grey1*grey2)));
      );
      
      
      //casteljau algorithm to evaluate and subdivide polynomials in Bernstein form.
      //poly is a vector containing the coefficients, i.e. p(x) = sum(0..N, i, poly_(i+1) * b_(i,N)(x)) where b_(i,N)(x) = choose(N, i)*x^i*(1-x)^(N-1)
      casteljau(poly, x) := (
        regional(alpha, beta);
        alpha = 1-x;
        beta = x;
        forall(0..N, k,
          repeat(N-k,
            poly_# = alpha*poly_# + beta*poly_(#+1);
          );
        );
        poly //the bernstein-coefficients of the polynomial in the interval [x,1]
      );

      //evaluates a polynomial, represented as vector of coefficients in bernstein-form
      eval(poly, x) := casteljau(poly, x)_1;
      
      //this function has to be called whenever fun changes
      init() := (
        dx = .05; dy = -.02;
        
        phi = -.1;
        lambda = pi/3;
        
        diff(p(z), z, dp(z) := #);
        diff(q(z), z, dq(z) := #);
        
          //newN = degree(fun(x,y,z), x, y, z);
          newN = max(2+2*degree(q(z),z), 2*degree(p(z),z));
          if(degree(p(z),z)==-1 % degree(q(z),z)==-1, newN=1000);
          if(newN!=N,
            N = newN;
            //The following line is DIRTY, but it makes the application run smooth for high degrees. :-)
            //Nethertheless, it might cause render errors for high degree surfaces. In fact, only a subset of the surface is rendered.
            //Adapt limit according to hardware.
            //values of kind 4*n-1 are good values, as it means to use vectors of length 4*n.
            N = min(N,11);
            
            //N+1 Chebyshev nodes for interval (0, 1)
            li = apply(1..(N+1), k, (cos((2 * k - 1) / (2 * (N+1)) * pi)+1)/2);
            
            //A is the matrix of the linear map that evaluates a polynomial in bernstein-form at the Chebyshev nodes
            A = apply(li, node,
              //the i-th column contains the values of the (i,N) bernstein polynomial evaluated at the Chebyshev nodes
              apply(0..N, i, eval(
                apply(0..N, if(#==i,1,0)), // e_i = [0,0,0,1,0,0]
                node //evaluate  b_(i,N)(node)
              ))
            );
            
            B = (inverse(A)); //B interpolates polynomials (in Bernstein basis), given the values [p(li_1), p(li_2), ...]


          );
          
      );
      init();
      
      //B3 is a matrix that interpolates quadratic polynomials (in monomial basis), given the values [p(-2), p(0), p(2)]
      B3 = inverse(apply([-2, 0, 2], c, apply(0 .. 2, i, c ^ i)));



      //compute the color for the pixel at position pixel assuming that the surface has been intersected at ray(dst)
      colorize(pixel, dst) := (
        regional(x, normal);
        x = ray(dst); //the intersection point in R^3

        xi = complex([x.x, x.y]/zoom);
        color = color(p(xi)/q(xi));
        factor = 0.5;
                    
        normal = dF(x);
        normal = normal / |normal|;

        ldir = ray(0);
        ldir = ldir /|ldir|;
        color*(.5+.2*abs(normal*(.3,.5,.6)) + .3*abs(normal*ldir)) + .5*[1,1,1]*(normal*ldir)^16
      );

      //what color should be given to pixel with pixel-coordinate pixel (vec2)
      computeColor(pixel, l, u, color) := (
        regional(a, b);
        //traverse binary tree (DFS) using heap-indices
        //1 is root node and node v has children 2*v and 2*v+1
        id = 1; 
        //maximum number of steps
        intersect = false;
        repeat(min(newN*7,50),
          //id=0 means we are done; do only a DFS-step if we are not finished yet
          if(!intersect & id>0,
            s = gets(id); //s = floor(log_2(id))
            
            //the intervals [a,b] are chossen such that (id in binary notation)
            //id = 1   => [a,b]=[l,u]
            //id = 10  => [a,b]=[l,(u+l)/2]
            //id = 101 => [a,b]=[l,(u+3*l)/4]
            //id = 11  => [a,b]=[(u+l)/2,u]
            //...
            a = l + (u-l)*((id+0)/s-1);
            b = l + (u-l)*((id+1)/s-1);
            
            //how many sign changes has F(ray(·)) in (a,b)?
            cnt = nsign(pixel, a, b);
            if(cnt == 1 % (b-a)<1e-4, //in this case we found a root (or it is likely to have a multiple root)
              //=>colorize and break DFS
              intersect = true;
              id = next(id),
            if(cnt == 0, //there is no root
              id = next(id), //break DFS
              
              //otherwise cnt>=2: there are cnt - 2*k roots.
              id = 2*id;  //visit first child within DFS
            )
        );  
        ));
        if(intersect, colorize(pixel, bisectf(pixel, a, b)), color)
      );
      

      nsign(pixel, a, b) := ( //Descartes rule of sign for the interval (a,b)
        //obtain the coefficients in bernstein basis of F along the ray in interval (a,b) by interpolation within this interval
        poly = B * apply(li,
          F(ray(a+#*(b-a))) //evaluate F(ray(·)) along Chebyshev nodes for (a,b)
        );
        //count the number of sign changes
        ans = 0;
        last = poly_1;
        forall(2..(N+1), k,
          if(last == 0, last = poly_k;);
          if(min(last, poly_k) < 0 & 0 < max(last, poly_k), //sign switch; avoid products due numerics
            ans = ans + 1;
            last = poly_k;
          );
        );
        ans //return value
      );
      
      
      //bisect F(ray(·)) in [x0, x1] assuming that F(ray(x0)) and F(ray(x1)) have opposite signs
      bisectf(pixel, x0, x1) := (
          regional(v0, v1, m, vm);
          v0 = F(ray(x0));
          v1 = F(ray(x1));
          repeat(11,
              m = (x0 + x1) / 2; vm = F(ray(m));
              if (min(v0,vm) <= 0 & 0 <= max(v0, vm), //sgn(v0)!=sgn(vm); avoid products due numerics
                  (x1 = m; v1 = vm;),
                  (x0 = m; v0 = vm;)
              );
          );
          m //return value
      );
      
      //id encodes a node in a binary tree using heap-indices
      //1 is root node and node v has children 2*v and 2*v+1
      //computes s=2^depth of a node id: Compute floor(log_2(id));
      //purpose: id corresponds interval [id-s,id+1-s]/s
      gets(id) := (
        s = 1;
        repeat(15,
          if(2*s<=id,
            s = 2*s;
          )
        );
        s //return value
      );
      
      //determines the next node in the binary tree that would be visited by a regular in DFS
      //if the children of id are not supposed to be visited
      //In interval logic: finds the biggest unvisited interval directly right of the interval of id.
      next(id) := (
        id = id+1;
        //now: remove zeros from right (in binary representation) while(id&1) id=id>>1;
        repeat(15,
          if(mod(id,2)==0,
            id = floor(id/2);
          )
        );
        if(id==1, 0, id) //return value - id 0 means we stop our DFS
      );
      </script>

          <script id="csdraw" type="text/x-cindyscript">
            //the following is executed for every rendered frame
      if (dragging,
          dx = 3 * (sx - mouse().x); dy = 3 * (sy - mouse().y);,
          dx = .9*dx; dy = .9*dy;
      );
      
      sx = mouse().x;
      sy = mouse().y;
      
      //the rotation matrix: It is modified either if the user is dragging or time passes
      phi = phi + dx;
      lambda = lambda + dy;
      lambda = min(max(lambda,-pi/2),pi/2);
      mat =
      (
        (1,0,0),
        (0,0,1),
        (0,1,0)
      )*
      (
          (cos(phi), 0, -sin(phi)),
          (0, 1, 0),
          (sin(phi), 0, cos(phi))
      )*
      (
          (1, 0, 0),
          (0, cos(lambda), -sin(lambda)),
          (0, sin(lambda), cos(lambda))
      );
      
      
      //the 3 sliders at the left.
      PA.x = 0.55;
      if (PA.y > .4, PA.y = .4);
      if (PA.y < -.4, PA.y = -.4);
      a = smootha((.5 + PA.y/.7));


      PC.x = 0.65;
      if (PC.y > .4, PC.y = .4);
      if (PC.y < -.4, PC.y = -.4);
      zoom = exp(3 * PC.y - 1);

      
      rd = (0,0,1);
      colorplot(
        rd = (sin(.5*#.x), sin(.5*#.y), cos(.5*#.x)*cos(.5*#.y)); //unit length vector of ray direction
        mrd = mat*rd;
        mv = mat*(0, 0, -5);

        l = max([
          min((1-mv.x)/mrd.x, (-1-mv.x)/mrd.x),
          min((1-mv.y)/mrd.y, (-1-mv.y)/mrd.y),
          min((1-mv.z)/mrd.z, (-.7-mv.z)/mrd.z)
        ]);
        
        u = min([
          max((1-mv.x)/mrd.x, (-1-mv.x)/mrd.x),
          max((1-mv.y)/mrd.y, (-1-mv.y)/mrd.y),
          max((1-mv.z)/mrd.z, (-.7-mv.z)/mrd.z)
        ]);
        
        color = gray(0.7);
        if(l<u,
          color = computeColor(#, l, u, color);
        );
        color
      );
      
        /*
      colorplot(
        spolyvalues = apply([-2, 0, 2], v, S(ray(#, v))); //evaluate S along ray
        spoly = B3 * spolyvalues;                         //interpolate to monomial basis
        D = (spoly_2 * spoly_2) - 4. * spoly_3 * spoly_1; //discriminant of spoly
        
        color = gray(0.7); //the color, which will be returned
        if (D >= 0, //ray intersects ball
          color = computeColor(
            #,
            (-spoly_2 - re(sqrt(D))) / (2 * spoly_3), //intersection entering the ball
            (-spoly_2 + re(sqrt(D))) / (2 * spoly_3), //intersection leaving the ball
            color
          );
        );
        color //return value
      ); //render the scene. # is the pixel coordinate
      */
      
      //drawtext((-.65, -.45), "degree: $" + if(newN<100,newN,"\infty") +"$");

      //lines for the sliders
      draw((.55, .4), (.55, -.4), color -> (0, 0, 0));
      drawtext((.48, -.439),"a = " + round(a * 100) / 100 + "");
      //draw((.6, .4), (.6, -.4), color -> (0, 0, 0));
      draw((.65, .4), (.65, -.4), color -> (0, 0, 0));
      drawtext((.64, -.441),"Z-");
      drawtext((.64, .420),"Z+");
      </script>


          </script>

          <div id="applet">
            <div class="w3-hide-small">

              <div id="CSCanvas" style="border:0px"></div>


              <script type="text/javascript">
                var cdy = CindyJS({
                  canvasname: "CSCanvas",
                  scripts: "cs*",
                  animation: {
                    autoplay: true
                  },
                  csconsole: false,
                  use: ["CindyGL", "symbolic"],
                  geometry: [{
                      name: "PA",
                      kind: "P",
                      type: "Free",
                      pos: [.5, .355, 1],
                      narrow: true,
                      color: [1, 1, 1],
                      size: 8
                    },
                    {
                      name: "PC",
                      kind: "P",
                      type: "Free",
                      pos: [.5, .1, 1],
                      narrow: true,
                      color: [0, 1, 1],
                      size: 8
                    }
                  ],
                  ports: [{
                    id: "CSCanvas",
                    width: 790,
                    height: 520,
                    transform: [{
                      visibleRect: [-0.7, -0.5, 0.7, 0.5]
                    }]
                  }]
                });
              </script>
              <br>

              <!--<span style="font-size:18px">f(z) = </span><input type="text" id="inp" value="(z-1)/(z^2+z+a)"  onkeypress="if((event.which ? event.which : event.keyCode)==13) { cdy.evokeCS('fun(z) := (' + this.value + '); init();'); }" size="55" style="font-size:18px">-->
            </div>


            <script type="text/javascript"
              src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
            </script>
            <script type="text/x-mathjax-config">
              MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>


            <div class="w3-hide-small">
              <div style="display: flex; justify-content: space-between; width: 800px;">
                <p>Selecciona una función f(z) de la siguiente lista:
                  <select id="sel" style="width:10em;">
                    <option data-a="1" data-p="z-1" data-q="z^2+z+1">(z-1)/(z^2+z+1)</option>
                    <option data-a="1" data-p="z">z</option>
                    <option data-zoom=".15" data-p="z^2">z^2</option>
                    <option data-a="1" data-zoom="0.1" data-q="z">1/z</option>
                    <option data-a="1" data-zoom="0.1" data-q="z^3">1/z^3</option>
                    <option data-zoom="0.1" data-p="z^7+z+2">z^7+z+2</option>
                    <option data-a="1" data-zoom="0.1" data-q="z^5-1">1/(z^5-1)</option>
                    <option data-a="1" data-zoom="0.1" data-p="z^5+1" data-q="z^5-1">(z^5+1)/(z^5-1)</option>
                    <option data-a="1" data-p="z-1" data-q="z*z+1">(z-1)/(z*z+1)</option>
                    <option data-a="1" data-p="z*z+1" data-q="z*z-1">(z*z+1)/(z*z-1)</option>
                    <option data-a="1" data-q="z^round(20*a-10)-1">1/(z^round(20*a-10)-1)</option>
                    <option data-a="1" data-p="sqrt(z)">sqrt(z)</option>
                    <option data-a="1" data-p="log(z)">log(z)</option>
                    <option data-a="1" data-p="sin(z)">sen(z)</option>
                    <option data-a="1" data-p="exp(z)">exp(z)</option>
                    <option data-a="1" data-p="sqrt(1-z*z)">sqrt(1-z*z)</option>
                    <option data-a="1" data-zoom="0" data-p="sin(z)" data-q="cos(z)">tan(z)</option>
                    <option data-a=".2" data-p="sin(z+3*a)" data-q="sin(z+i)">sen(z+3*a)/sen(z+i)</option>
                    <option data-a="1/3" data-zoom="0.1" data-q="sin(pi*a+z^3)">1/sen(pi*a+z^3)</option>
                    <option data-a="1" data-zoom="0.05" data-q="sin((z+1)/(z-1))">1/sen((z+1)/(z-1))</option>
                    <option data-a="1" data-zoom="-.2" data-p="z^z">z^z</option>
                    <option data-a="1" data-zoom="-.2" data-p="log(z^z)" data-q="z">log(z^z)/z</option>
                  </select></p>
                <div><a href="../applets/cindyjs/dclandscape/" target="_blank" title="Open Tab"><i
                      class="fas fa-expand"></i></a></div>
              </div>
            </div>

            <script type="text/javascript">
              var select = document.getElementById("sel");
              select.addEventListener('change', function (event) {
                var p = this.options[this.selectedIndex].getAttribute("data-p") || "1";
                var q = this.options[this.selectedIndex].getAttribute("data-q") || "1";

                //document.getElementById('inpp').value = p;
                //document.getElementById('inpq').value = q;

                cdy.evokeCS('p(z) := (' + p + '); q(z) := (' + q + '); init();');

                var a = this.options[this.selectedIndex].getAttribute("data-a") || .5;
                cdy.evokeCS('seta(' + a + ')');

                var zoom = this.options[this.selectedIndex].getAttribute("data-zoom");
                if (zoom) cdy.evokeCS('setzoom(' + zoom + ')');

              }, false);
            </script>

          </div>
          <!--Applet ends-->

          <div class="w3-hide-large w3-hide-medium w3-khaki w3-round w3-padding w3-panel">
            <p><i class="fas fa-sad-tear"></i> 
              Lo siento, este applet no funciona para dispositivos con pantallas pequeñas. 
              Rota tu dispositivo horizontalmente. O cambia el tamaño de tu ventana de tal forma 
              que el ancho es mayor que el largo.
            </p>
          </div>

          <br>
          <hr>

          <p>
            En la práctica, a menudo es difícil generar superficies analíticas que nos 
            permitan leer las propiedades de la función compleja de manera fácil y precisa. 
            Un enfoque alternativo no solo es más simple sino incluso más general: 
            en lugar de dibujar un gráfico en $\mathbb R^3$, podemos representar una función directamente 
            en su dominio codificando con colores sus valores por completo. 
            Este método se llama <em>dominio coloreado</em>.
          </p>

          <br>
          <hr>

          <p style="font-size: 16px"><strong>Nota:</strong> El último applet fue escrito por <a
              href="https://geo.ma.tum.de/en/people/aaron-montag.html">Aaron Montag</a> usando <a
              href="https://cindyjs.org/">CindyJS</a>. El código fuente se puede encontrar en <a
              href="https://github.com/complex-analysis/complex-analysis.github.io/tree/master/applets/cindyjs/analyticlandscape">GitHub.</a>
          </p>

        </div> <!-- end complex analytic landscapes -->

        <!-- link to the next page -->
        <a href="dominio_coloreado.html">
          <p class="nextPage">NEXT: Dominio Coloreado</p>
        </a>
        <footer>
          <p>[ <a href="../es.html">intro</a>, <a href="https://github.com/complex-analysis">source</a>, <a
              href="https://github.com/complex-analysis/complex-analysis.github.io/issues">issues</a> ]</p>

          <p class="license">
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
              <img id="license" alt="Creative Commons License" style="border-width:0"
                src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png">
            </a>
            <br />
            <strong style="font-size: 18px">ISBN: 978-0-6485736-0-9</strong> <br>
            <strong style="font-size: 18px">2019</strong>
          </p>
        </footer>

  </div> <!-- end wrapper -->

  <!-- nice smart quotes, via: http://smartquotesjs.com -->
  <script src="../js/smartquotes.min.js"></script>
  <script src="../applets/cindyjs/assets/app.js"></script>
</body>

</html>